-- helper API for working with redstone
-- include "ignored" lines

-- FIXME: decouple setColor() from the input bus (remember a currentPattern, and optionally merge it with the input)

local ignorePattern = 0 -- these colors may never be set

local inputSide = 'left'
local outputSide = 'right'

local pulsers = {}

local doDebug = false

--
-- API -----------------------------------
--

-- Set the sides to use for input/output by default
function setDefaultSides(input, output)
	inputSide = input
	outputSide = output
end

-- enable/disable debugging output
function setDebugging(debugFlag)
	doDebug = debugFlag
end

function registerIgnoreColor(color)
	colors.combine(ignorePattern, color)
end

function unregisterIgnoreColor(color)
	colors.subtract(ignorePattern, color)
end

-- Register a pulser to be handled by pulserTick().
-- The pulser will pulse <color> with <interval> seconds between pulses 
-- <duration> seconds in length, up to a maximum of <maxcount> pulses
-- (<maxcount> == 0 means forever)
function registerPulser(name, color, interval, duration, maxcount)
	local pulser = {color = color, interval = interval or 1, duration = duration or 0.1, maxcount = maxcount or 0}

	pulser.age = pulser.interval -- start with pulse
	pulser.state = false
	pulser.count = 0

	print("Reg: ", name, ": ", pulser.color, ", ", pulser.interval, ", ", pulser.duration, ", ", pulser.maxCount, ", ", pulser.age, ", ", pulser.count) 
	pulsers[name] = pulser
end

function unregisterPulser(name)
	pulsers[name] = nil
end

-- Process one "pulser tick", i.e. treat all pulsers as if
-- <timeSinceLastTick> seconds have passed (default: 0.1).
-- This is intended to be called from a "while .. sleep .. end" loop
-- that typically also handles other logic.
function pulserTick(timeSinceLastTick)
	local delay = timeSinceLastTick or 0.1
	local pulsersToRemove = {}

	for name, spec in pairs(pulsers) do
		spec.age = spec.age + delay
	
		local maxAge
		if(spec.state == true) then
			maxAge = spec.duration
		else
			maxAge = spec.interval
		end
	
		if(spec.age >= maxAge) then
  			spec.state = not spec.state
  			
  			if(spec.state) then
  				-- count when switching the signal on
	  			spec.count = spec.count + 1
  			end
  			
  			if(doDebug) then
  				print ("Setting " , name , " to " , spec.state, " (#", spec.count, ")")
  			end
  			
  			setColor(spec.color, spec.state)
  			spec.age = 0
  			
  			-- If the signal is off again and has exceeded its maxcount, remove the pulser
  			if((not spec.state) and (spec.maxcount > 0) and (spec.count >= spec.maxcount)) then
  				pulsersToRemove[#pulsersToRemove + 1] = name
  			end
  		end
	end
	
	for i, name in pairs(pulsersToRemove) do
		unregisterPulser(name)
	end
end


function waitForColor(color, value, side)
	side = side or inputSide
	
	local wait = true
	while wait do
		event, p1, p2, p3, p4, p5 = os.pullEvent()
		if event == "redstone" then
			bcolors = redstone.getBundledInput(side)
			wait = colors.test(bcolors, color)
			if value then
				wait = not wait
			end
		end
	end
end

function setColor(color, value, side)
	side = side or outputSide
	
    local currentPattern = redstone.getBundledInput(side)
	if(value) then
		currentPattern = colors.combine(currentPattern, color)
	else
		currentPattern = colors.subtract(currentPattern, color)
	end
	currentPattern = colors.subtract(currentPattern, ignorePattern)
	
	redstone.setBundledOutput(side, currentPattern)
end

function clearAllColors(side)
	side = side or outputSide
	redstone.setBundledOutput(side, 0)
end